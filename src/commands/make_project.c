#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h>
#include <sys/stat.h> // For the 'mkdir' function
#include <stdarg.h>

// For reading files
#ifdef _WIN32
#include <windows.h>
#include <direct.h> // for _getcwd
#define PATH_SEPARATOR "\\" // Windows' weird things (idiot Bill Gates)
#define getcwd _getcwd // so that its the same later
#else
#include <unistd.h> // for gecwd
#define PATH_SEPARATOR "/" // for sane people
#endif

#include "commands/command.h"
#include "commands/make_project.h"
#include "utils.h"

int make_project(char **args) {
	d_showInput("make_project", args);
	
	// If there if an argument
	if (args[2] != NULL) {
		e_fatal("'make_project' command does not support arguments\n");
		return 1;
	}
	
	// Check if name is provided
	if (strcmp(g_vals[1][0], "") == 0) {
		e_fatal("name is required to create a project\n");
		return 1;
	}

	char *name = g_vals[1][0];

	char *userpath= NULL;
	// Check if adess should use a path defined by the user
	if (strcmp(g_vals[3][0], "") != 0) {
		userpath = g_vals[3][0];
	}

	char *path = getCurDirectory(userpath);

	// If inside an adess project
	if (checkFileExistsIn(path, ".adess")) { // search for anything that contains '.adess', kind of like 'grep'
		e_fatal("already inside adess project\n");
		return 1;
	}

	path = strcat(path, name);

	// If making the project directory fails, abort
	if (makeDirectory(path)) {
		return 1;
	}

	char projectFilePath[4096];
	snprintf(projectFilePath, 4096, "%s%s%s%s", path, PATH_SEPARATOR, name, ".adess");
	makeFile(projectFilePath);
	
	// Exit if option -e (empty) is enabled
	if (g_opts[5] == true) {
		n_print("created empty project '%s' at '%s'\n", name, path);
		return 0;
	}

	// Make 'engines', 'scenes' and 'output' directory
	char enginePath[4096], scenePath[4096], outputPath[4096];
	
	// Set correct directories and add them to the 'project.adess' file
	snprintf(enginePath, 4096, "%s%s%s", path, PATH_SEPARATOR, "engines");
	snprintf(scenePath, 4096, "%s%s%s", path, PATH_SEPARATOR, "scenes");
	snprintf(outputPath, 4096, "%s%s%s", path, PATH_SEPARATOR, "output");

	// Make the directories
	makeDirectory(enginePath);
	makeDirectory(scenePath);
	makeDirectory(outputPath);

	// Append base config into the <name>.adess file
	appendProjectDefault(projectFilePath);

	n_print("created project '%s' at '%s'\n", name, path);
	
	return 0;
}

void appendProjectDefault(char *path) {
	// Add default things into project file
	appendLine(path, "// This file was generated by adess\n");

	// Define audio signal parameters
	appendLine(path, "\n// Audio signal parameters\n");
	appendLine(path, "sample_rate = 44100\n");
	appendLine(path, "bit_depth = 16\n");

	// Define adess parameters
	appendLine(path, "\n// General adess-specific variables\n");
	appendLine(path, "debug = false\n");
	appendLine(path, "max_buffer_size = 8589934592\n");
	appendLine(path, "amplitude_clip = true\n");
	appendLine(path, "engine_path = \"engines\"\n");
	appendLine(path, "scene_path = \"scenes\"\n");
	appendLine(path, "output_path = \"output\"\n");
}

int makeDirectory(char *path) {
	// Check if directory already exists
	if (access(path, F_OK) != -1) {
		e_fatal("could not create directory '%s', already exists\n", path);
		return 1;
	}

	// 0755 is for permissions, it is extremely strange
	if (mkdir(path, 0755) != 0) {
		e_fatal("could not create directory at: 's'\n", path);
		return 1;
	}

	d_print("directory created at '%s'\n", path);
	
	return 0;
}

int makeFile(char *path) {
	// Check if the file already exists
	if (access(path, F_OK) != -1) {
		e_fatal("could not create file '%s', already exists\n", path);
		return 1;
	}

	FILE *file;
	file = fopen(path, "a");

	if (file == NULL) {
		e_fatal("could not create file at: '%s'\n", path);
		return 1;
	}
	
	fclose(file);

	d_print("file created at '%s'\n", path);

	return 0;
}

int appendLine(char *path, const char *format, ...) {
	va_list args;
	va_start(args, format);
	
	FILE *file;
	
	file = fopen(path, "a");
	
	if (file == NULL) {
		fclose(file);
		e_fatal("failed to write into file '%s'\n", path);
		return 1;
	}

	vfprintf(file, format, args);
	
	va_end(args);
	fclose(file);
	return 0;
}
